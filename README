EN.600.344
Computer Network Fundamentals
Project 3 - PWOSPF
Group 1
      Dan Crankshaw
      Maddie Stone
      Adam Gross
      
      
Add a note to the final writeup about efficiency and implementation writeups

DONE?
-read in static routing table --> This is the routing table from the simple router
-*need to make sure everything (e.g. pwospf_iface) is initialized in pwospf_init()
-Handle default gateways (i.e. to the internet) - will be handled in the static routes
-update get_routing_if() in sr_router.c to first check dynamic forwarding table, then static one
-add router when we get an advert about one we don't know about (decide what exactly to put in the
 properties of the router, and will this affect Dijkstra's at all)
 		-add check to make sure that router's with same subnet don't advertise different neighbors
 		 (*see better comment in the code)
-I think I still need to update the LSUTIMEOUT's of each route struct when I add to them
	-also need to check whether they are expired or not probably
-write set and get sequence methods
-handle ospf packets (in sr_router.c) - method stub is there, it just needs to be written
-decide when we have an invalid link
-drop LSU packets
-create and read in config file (with router id, area id, etc.)
	-make sure that all struct pwospf_subsys variable are initialized in pwospf_init()
	-all threading
	-including possibly ARP
-buffering LSU packets
-finish ospf_subsystem initialization



TODO:


-comment out __attribute-- ((packed)) for structs that don't need them?????
-free all malloced members of structs in buffers
-need a netmask config file

-find out what entries need to be in static routing table. Rtable's must have at least 1 entry
 
-probably some other stuff too


Notes:

This is so we each have a section of the README to pose questions to each other, add notes about
our particular pieces of code, etc. Only delete things from your section.

Dan:
-Check_top_invalid for some reason is not working - gives us segfaults
		***COMMENTED OUT RIGHT NOW***
		**Check top invalid made if statement of 1==0
-Create static routing tables for vhost 2 and 3 that will mirror entries in the dynamic routing table
-conditional wait for LSU packets (so that we send packets every LSUINT seconds AND whenever we
 get a change to the link state update- p_thread_cond_wait()

Maddie:
--TEST FORWARDING--Commented out right now.
--Are ARP Replies correctly being added to cache
--- We seem to be adding multiple requests for the same dest to arpq










For the non-aligned pointer being freed error - Could we be freeing somethign that was never malloced????
	do we malloc then memmove? do we need to?
	
	
void add_new_route(struct sr_instance *sr, struct route* current, struct router* host)
{
	
	/*Need to resize subnet buffer*/
	if(host->subnet_buf_size == host->subnet_size)
	{
		struct route** temp = realloc(host->subnets, 2*host->subnet_buf_size);
		assert(temp);
		host->subnets = temp; //double size of array
		host->subnet_buf_size *= 2;
	}
	
	/*add to adj_list*/
	//int invalid = 0;
	if(current->r_id != 0)
	{
		if(host->adj_buf_size == host->adj_size)
		{
			host->adjacencies = realloc(host->adjacencies, 2*host->adj_buf_size);
			host->adj_buf_size *= 2;
		
		}
		/*get router pointer to add to adj list*/
		struct adj_list *cur_router = sr->ospf_subsys->network;
		int added = 0;
		while(cur_router)
		{
			struct in_addr adj_r_id;
			adj_r_id.s_addr = current->r_id;
			//struct in_addr host_router_id;
			//host_router_id.s_addr = cur_router->rt->rid;
			if(cur_router->rt->rid == current->r_id)
			{
				added = 1;
				if(cur_router->rt->adj_buf_size == cur_router->rt->adj_size)
				{
					cur_router->rt->adjacencies = realloc(cur_router->rt->adjacencies, 2*cur_router->rt->adj_buf_size);
					cur_router->rt->adj_buf_size *= 2;
				}
				//fprintf(stderr, "Found matching router\n");
				struct route* other_sub = router_contains_subnet(cur_router->rt, current->prefix.s_addr);
				if(other_sub != NULL)
				{
					
					/*TODO: decide whether this will break anything!!!!!!!*/
					//other_sub->r_id = ntohl(other_sub->r_id);
					if(other_sub->mask.s_addr != current->mask.s_addr)
					{
						fprintf(stderr, "Non-matching masks - removed a subnet\n");
						remove_rt_sn_using_id(sr, cur_router->rt, other_sub->r_id);
						//invalid = 1;
					}
					else if(other_sub->r_id != host->rid)
					{
						if(other_sub->r_id == 0)
						{
							other_sub->r_id = host->rid; /*Update the router ID*/
							/*Add host to cur_router's adj_list*/
							int j;
							int exists = 0;
							for(j = 0; j < cur_router->rt->adj_size; j++)
							{
								if(cur_router->rt->adjacencies[j]->rid == host->rid)
								{
									exists = 1;
									break;
								}
							}
							if(exists == 0)
							{
								//fprintf(stderr, "This should happen\n");
								//fprintf(stderr, "Adding to adjacency list\n");
								cur_router->rt->adjacencies[cur_router->rt->adj_size] = host;
								cur_router->rt->adj_size++;
							}
						}
						else
						{
							fprintf(stderr, "Non-matching IDs - removed a subnet\n");
							struct in_addr subid;
							subid.s_addr = other_sub->r_id;
							struct in_addr hostid;
							hostid.s_addr = host->rid;
							fprintf(stderr, "other_sub->r_id = %s, ", inet_ntoa(subid));
							fprintf(stderr, "host->rid = %s\n", inet_ntoa(hostid));
							remove_rt_sn_using_id(sr, cur_router->rt, other_sub->r_id);
							//invalid = 1;
						}
					}
					else
					{
						
						int j;
						int exists;
						exists = 0;
						for(j = 0; j < host->adj_size; j++)
						{
							if(host->adjacencies[j]->rid == cur_router->rt->rid)
							{
								exists = 1;
								break;
							}
						}
						if(exists == 0)
						{
							host->adjacencies[host->adj_size] = cur_router->rt;
							host->adj_size++;
						}
						
						exists = 0;
						for(j = 0; j < cur_router->rt->adj_size; j++)
						{
							if(cur_router->rt->adjacencies[j]->rid == host->rid)
							{
								exists = 1;
								break;
							}
						}
						if(exists == 0)
						{
							cur_router->rt->adjacencies[cur_router->rt->adj_size] = host;
							cur_router->rt->adj_size++;
						}
						
						added = 1;
					}
				
				}
				else
				{
					//fprintf(stderr, "Added new connection\n");
					//fprintf(stderr, "Adding to adjacency list\n");
					cur_router->rt->adjacencies[cur_router->rt->adj_size] = host;
					cur_router->rt->adj_size++;
					host->adjacencies[host->adj_size] = cur_router->rt;
					host->adj_size++;
					
					cur_router->rt->subnets[cur_router->rt->subnet_size] = (struct route*)malloc(sizeof(struct route));
					memmove(cur_router->rt->subnets[cur_router->rt->subnet_size], current, sizeof(struct route));
					/*change neighbor ID to hosts (it was originally cur_routers)*/
					cur_router->rt->subnets[cur_router->rt->subnet_size]->r_id = host->rid;
					cur_router->rt->subnet_size++;
					added = 1;
				}
				
				host->subnets[host->subnet_size] = (struct route*)malloc(sizeof(struct route));
				memmove(host->subnets[host->subnet_size], current, sizeof(struct route));
				host->subnet_size++;
				break;
				
			}
			else
			{
				cur_router = cur_router->next;
			}
		}
		if(!added)
		{
			//fprintf(stderr, "created new router\n");
			struct router *new_adj = add_new_router(sr, current->r_id);
			host->adjacencies[host->adj_size] = new_adj;
			host->adj_size++;
		    host->subnets[host->subnet_size] = (struct route*)malloc(sizeof(struct route));
			memmove(host->subnets[host->subnet_size], current, sizeof(struct route));
			host->subnet_size++;
			
			struct route* opp_route = (struct route*) malloc(sizeof(struct route));
			memmove(opp_route, current, sizeof(struct route));
			opp_route->r_id = host->rid;
			
			new_adj->adjacencies[new_adj->adj_size] = host;
			new_adj->adj_size++;
		    new_adj->subnets[new_adj->subnet_size] = (struct route*)malloc(sizeof(struct route));
			memmove(new_adj->subnets[new_adj->subnet_size], opp_route, sizeof(struct route));
			new_adj->subnet_size++;
			
			//add_new_route(sr, opp_route, new_adj);
		    free(opp_route);
		}
	}
	
	
	else
	{
			host->subnets[host->subnet_size] = (struct route*)malloc(sizeof(struct route));
			memmove(host->subnets[host->subnet_size], current, sizeof(struct route));
			host->subnet_size++;
	}
}