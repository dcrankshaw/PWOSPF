EN.600.344
Computer Network Fundamentals
Project 3 - PWOSPF
Group 1
      Dan Crankshaw
      Maddie Stone
      Adam Gross
      
      
      
      
Add a note to the final writeup about efficiency and implementation writeups

DONE?
-read in static routing table --> This is the routing table from the simple router
-*need to make sure everything (e.g. pwospf_iface) is initialized in pwospf_init()
-Handle default gateways (i.e. to the internet) - will be handled in the static routes
-update get_routing_if() in sr_router.c to first check dynamic forwarding table, then static one
-add router when we get an advert about one we don't know about (decide what exactly to put in the
 properties of the router, and will this affect Dijkstra's at all)
 		-add check to make sure that router's with same subnet don't advertise different neighbors
 		 (*see better comment in the code)
-I think I still need to update the LSUTIMEOUT's of each route struct when I add to them
	-also need to check whether they are expired or not probably
-write set and get sequence methods
-handle ospf packets (in sr_router.c) - method stub is there, it just needs to be written
-decide when we have an invalid link
-drop LSU packets
-create and read in config file (with router id, area id, etc.)
	-make sure that all struct pwospf_subsys variable are initialized in pwospf_init()
	-all threading
	-including possibly ARP
-buffering LSU packets
-finish ospf_subsystem initialization


TODO:
-make sure that everywhere that I assume 2-IP subnet won't cause problems with the default
router to the internet
		-this may be okay because the default route is in the static routing table
-Locking and unlocking mutexes (esp in top_info.c, lsu.c, hello.c)
		-includes double-checking that we don't need to lock it anywhere else (like in sr_router,
		 arp, buffer)
-conditional wait for LSU packets (so that we send packets every LSUINT seconds AND whenever we
 get a change to the link state update
-Finish resolving issues between what Adam's add and delete neighbor methods do and what
 mine do. This includes the issues about initializing the interface subnets to RID = 0, then
 having to change it later on based on hello packets
-efficiency of ARP_cache delete method
-free all malloced members of structs in buffers
-need a netmask config file
 
 
-probably some other stuff too


Notes:

This is so we each have a section of the README to pose questions to each other, add notes about
our particular pieces of code, etc. Only delete things from your section.

Dan:


Maddie:
!!!!!! Remember to uncomment checksum check!!!!!!! cuz it doesn't work :(

Adam:




/uint8_t* construct_request(struct sr_instance* sr, const char* interface,const uint32_t ip_addr)
{
	/*Construct ARP Header*/
	struct sr_arphdr* request;
	request=(struct sr_arphdr*)malloc(sizeof(struct sr_arphdr));
	request->ar_hrd=htons(ARP_HRD_ETH);
	request->ar_pro=htons(ARP_PRO_IP);
	request->ar_hln=ETHER_ADDR_LEN;
	request->ar_pln=ARP_IP_LEN;
	request->ar_op=ARP_REQUEST;
	
	/* Find source interface */
	struct sr_if* iface=sr_get_interface(sr, interface); /*Find iface associated with rt entry */
	assert(iface); 
	memmove(request->ar_sha, iface->addr, ETHER_ADDR_LEN);
	request->ar_sip=iface->ip;  /*Set ARP source IP address to interface's IP address */
	
	/* Set ARP dest MAC address to 00:00:00:00:00:00 */
	int i=0;
	for(i=0; i<ETHER_ADDR_LEN; i++)
	{
		request->ar_tha[i]=0x00;
	}
	
	request->ar_tip=ip_addr;

	/*ARP Constructed, Now Construct Ethernet Header */
	struct sr_ethernet_hdr* new_eth;
	new_eth=(struct sr_ethernet_hdr*)malloc(sizeof(struct sr_ethernet_hdr));
	memmove(new_eth->ether_shost, iface->addr,ETHER_ADDR_LEN); /*Ethernet Source Address is Interface's Address */
	
	/*Set Ethernet dest MAC address to ff:ff:ff:ff:ff:ff (Broadcast) */
	for(i=0; i<ETHER_ADDR_LEN; i++)
	{
		new_eth->ether_dhost[i]=0xff;
	}
	
	new_eth->ether_type=htons(ETHERTYPE_ARP);
	
	int eth_offset=sizeof(struct sr_ethernet_hdr);
	
	/* Put new Ethernet and ARP Header in Response */
	uint8_t* arp_req=(uint8_t*) malloc(sizeof(uint8_t));
	memmove(arp_req, new_eth, eth_offset);
	memmove((arp_req + eth_offset), request, sizeof(struct sr_arphdr));
	
	
	
	/*Free Construct ARP and Ethernet Headers */
	if(request)
		free(request);
	if(new_eth)	
		free(new_eth);
		
	return arp_req;
}










void add_to_existing_router(struct sr_instance *sr, struct route **routes, struct router* host, int num_ads)
{
	/*TODO: this is pretty inefficient, it may be alright though if these stay small enough */
		int i;
		for(i = 0; i < num_ads; i++)
		{
			if(router_contains_subnet(routes[i], host) == 1)
			{
				if(router_contains(routes[i], host) == 0)
				{
					/*dont add connection, remove the existing connection in host*/
				}
			}
			else
			{
				add_new_route(sr, routes[i], host);
			}
			
		}
}