EN.600.344
Computer Network Fundamentals
Project 3 - PWOSPF
Group 1
      Dan Crankshaw
      Maddie Stone
      Adam Gross
      

*Note: for some reason, on our machines, the ip version number and the ip header length
were in the wrong bit order in the ip header struct (contained in sr_protocol.h). To fix this,
we switched it so that each is in the reverse order that the stub code had them.

Data Structures:
	-Topology: This implementation stores the topology as a linked list of routers.
		Each router has its own adjacency list (containing pointers to the other routers),
		as well as a matching list of subnets, which includes each router, as well as any
		application servers (or non routers) that this router is connected to. This adjacency
		list of routers is used in a computation of Dijkstra's algorithm to find the shortest
		path from the host router to each subnet in the topology. These shortest paths are then
		added to the dynamic forwarding table.
	-Interface list: The pwospf subsystem has its own interface list, creating using
		information from the interface list in the instance struct (struct sr_instance *sr),
		as well as additional information including an array of neighbors. These neighbors contain
		an entry for each neighbor sending the router hello packets. The list allows for arbitrarily
		many neighbors for any given interface.
	
	-We used unordered linked lists and arrays to build our data structures. We decided that
		because any individual list was relatively small (less than 10 elements), the overhead
		and added complexity of creating and maintaining ordered lists outweighed any benefits of
		added efficiency (i.e. when searching the lists).
		
PWOSPF subsystem:
	-The pwospf subsystem runs using a separate thread. This thread solely decides when to
		send packets (LSU's every 30 seconds, and hello packets every 5 seconds, although
		these are #define and can be easily changed), and sleeps to get the timing right.
		This thread accesses some global resources that the handle_packet thread accesses
		as well, and so we use mutexes to protect and serialize access to these shared resources.